#!/bin/bash

#COLOR CODES
GREEN_B='\033[1;32m'
RED_B='\033[1;31m'
YELLOW_B='\033[1;33m'
RESET='\033[0m'
GRAY_B='\033[1;37m'
UND='\033[4m'

# checks if interface is valid
checkinterface() {

	intf="$1"
	badString="Device \"${intf}\" does not exist."
	intstatus=$(ip addr show dev ${intf} 2>&1)

	if [ "${intstatus}" == "${badString}" ]; then
		echo -e "${RED_B}[-]${RESET} Could not locate interface ${intf}." >&2
		exit 1
	
	else
		echo "${intf}"
	fi
}

# checks if the port is valid
checkport() {

	port="$1"

	# checks if specified value is a number
	if [ -n "$port" ] && [ "$port" -eq "$port" ] 2>/dev/null; then
		
		# checks if port is a valid number
		if [ "$port" -lt "1" ] || [ "$port" -gt "65535" ]; then

			echo -e "${RED_B}[-]${RESET} Invalid port. Please specify a valid port number." >&2
			exit 1

		else
			echo "$port"
		fi

	else
		echo -e "${RED_B}[-]${RESET} Invalid port. Please specify a valid port number." >&2
		exit 1

	fi
}

# checks if target is valid
checktarget () {

	ip="$1"

	checkreg=$(echo "$ip" | egrep -c "\w{1,3}\.\w{1,3}\.\w{1,3}\.\w{1,3}$")
	if [ -z "$checkreg" ]; then

		echo -e "${RED_B}[-]${RESET} Invalid target. Please specify a valid IPv4 address." >&2
		exit 1

	fi


	for i in $(seq 1 4); do
		
		octet="$(echo ${ip} | cut -d '.' -f $i)"
		if [ "${octet}" -lt "0" ] || [ "${octet}" -gt "255" ]; then
			echo -e "${RED_B}[-]${RESET} Invalid target. Please specify a valid IPv4 address." >&2
			exit 1
		fi

	done

	echo "$ip"
}

# lists out all the rules
listrules () {

	list=$(iptables -t nat -nL | grep "Generated by Network Manager." | grep "DNAT")
	echo
	if [ -z "$list" ]; then
		echo -e "${RED_B}[-]${RESET} No rules to list." >&2

	else
		while read -r p; do
			listenport=$(echo "$p" | egrep -o "dpt:\w{1,5}.*/\*" | cut -d " " -f 1 | cut -d ":" -f 2)
			destport=$(echo "$p" | egrep -o "to:.*:\w{1,5}$" | cut -d ":" -f 3)
			destip=$(echo "$p" | egrep -o "to:.*:\w{1,5}$" | cut -d ":" -f 2)
			echo -e "${GREEN_B}[+]${RESET} LISTENING PORT ${GRAY_B}${listenport}${RESET} FORWARDING TO ${GRAY_B}${destip}:${destport}${RESET}"
		done <<< "$list"
	fi

	echo
}

# help page
printusage () {

	echo -e "${GRAY_B}Usage:${RESET} portpush.sh -p ${UND}target port${RESET} -t ${UND}internal target${RESET} -i ${UND}outgoing interface${RESET} [-l ${UND}listening port${RESET}]"
	echo
	echo -e "-h | --help)        Display this help page."
	echo -e "-p | --target-port) Specifies the port of the internal target you want to communicate with."
	echo -e "-i | --interface)   Specifies the OUTGOING interface (whichever interface the internal host is connected to)."
	echo -e "-t | --target-ip)   Specifies the IPv4 address of the internla target you want to communicate with."
	echo -e "-l | --listen-port) Optional. Specifies the listening port. If unspecified, 50000 is added to the target port."
	echo -e "-d | --delete) 	    Deletes a specific pivoting rule based on a provided listening port."
	echo -e "-f | --flush) 	    Flushes out all rules created by portpush (and only those created by portpush)."
	echo -e "-L | --list) 	    List all the rules currently set by portpush."
	echo
	exit 1
}


deleterule () {

	dnatrule_number=$(iptables -t nat -nL --line-numbers | grep "DNAT" | grep "dpt:$1" | cut -d " " -f 1)

	if [ -z "$dnatrule_number" ]; then
		echo -e "${RED_B}[-]${RESET} No rules associated with port $1 could be located."
		echo -e "${RED_B}[-]${RESET} Make sure you are specifying the LISTENING port."
		exit 1
	fi

	associated_snat=$(iptables -t nat -nL --line-numbers | grep "$1" | rev | cut -d " " -f 1 | rev)
	snat_port=$(echo "$associated_snat" | cut -d ":" -f 3)
	snat_ip=$(echo "$associated_snat" | cut -d ":" -f 2)
	snatrule_number=$(iptables -t nat -nL --line-numbers | egrep "$snat_ip.*tcp dpt:$snat_port" | cut -d " " -f 1)
	iptables -t nat -D PREROUTING "$dnatrule_number"
	iptables -t nat -D POSTROUTING "$snatrule_number"
	echo -e "${GREEN_B}[+]${RESET} Rule has been successfully deleted."
	exit 1
}


FLUSH_RULES=0
INTERFACE=
TARGET_PORT=
LISTEN_PORT=
TARGET=

if [ "$(id -u)" != "0" ]; then
	echo -e "${YELLOW_B}[!]${RESET} You must run this script as root!"
	exit 1
fi

# enables routing, which is required for forwarding traffic.
echo 1 > /proc/sys/net/ipv4/ip_forward 

while [ "$1" != "" ]; do
	case $1 in

		-h | --help)

			printusage
			exit 1
			;;

		-i | --interface) 		
			
			shift
			INTERFACE=$(checkinterface "$1")
			IP_ADDR=$(ip addr show dev "$INTERFACE" | egrep -o "\w{1,3}\.\w{1,3}\.\w{1,3}\.\w{1,3}/\w{1,2}" | cut -d "/" -f  1)
			;;

		-p | --target-port) 	
			
			shift
			TARGET_PORT=$(checkport "$1")
			;;

		-l | --listen-port)		

			shift
			LISTEN_PORT=$(checkport "$1")
			;; 

		-t | --target-ip)	
			
			shift
			TARGET=$(checktarget "$1")
			;;

		-d | --delete)			

			shift
			deleterule "$1"
			;;
		
		-f | --flush)			

			FLUSH_RULES=1
			;;

		-L | --list)			

			listrules
			exit 1
			;;
	esac
	shift
done

#verifies the user actually wants to flush the rules
if [ "$FLUSH_RULES" -eq "1" ]; then
	echo -e "${YELLOW_B}[!]${RESET} Flushing will clear ALL NAT rules created by this script."
	read -p "    Are you sure you want to continue? (y/n): " flushverify
	
	if [ "$flushverify" == "n" ] || [ "$flushverify" == "N" ]; then
		echo -e "${YELLOW_B}[!]${RESET} Exiting without flushing . . ."
		exit 1

	elif [ "$flushverify" == "y" ] || [ "$flushverify" == "Y" ]; then
		ruleset=$(iptables -t nat -L --line-numbers | egrep "Generated by Network Manager" | egrep -o "^\w{1,4}.*.NAT")

		while [ -n "$ruleset" ]; do
		
			ruleset=$(iptables -t nat -L --line-numbers | egrep "Generated by Network Manager" | egrep -o "^\w{1,4}.*.NAT")
			while read -r i; do
				rulenumber=$(echo "$i" | egrep -o "^\w{1,4}.*.NAT" | cut -d " " -f 1)
				ruletype=$(echo "$i" | egrep -o "^\w{1,4}.*.NAT" | rev | cut -d " " -f 1 | rev)
			
				if [ "$ruletype" == "DNAT" ]; then
					iptables -t nat -D PREROUTING "$rulenumber"

				elif [ "$ruletype" == "SNAT" ]; then
					iptables -t nat -D POSTROUTING "$rulenumber"
				fi
		done <<< "$ruleset"
	done 2>/dev/null

	echo -e "${YELLOW_B}[!]${RESET} All ${GRAY_B}portpush${RESET} rules have been flushed."
	exit 1

	else
		echo -e "${YELLOW_B}[!]${RESET} Invalid option. Exiting without flushing . . ."
		exit 1

	fi
fi

if [ -z "$INTERFACE" ] || [ -z "$TARGET_PORT" ] || [ -z "$TARGET" ]; then

	echo -e "${RED_B}[-]${RESET} Insufficient information. Please specify an Interface, Target IP and Target Port." >&2
	exit 1
fi


# Core aspect of the script
if [ -z "$LISTEN_PORT" ]; then
	defaultport=$(expr 50000 + $TARGET_PORT)

	if [ "$defaultport" -gt "65535" ]; then
		echo -e "${RED_B}[-]${RESET} Due to the high target port number specified, the default behavior setting up a listening port cannot be used." >&2
		echo -e "${RED_B}[-]${RESET} Please explicitly state a listening port with the \"-l\" option." >&2
		exit 1
	fi

	echo -e "${YELLOW_B}[-]${RESET} No listening port has been specified."
	echo -e "${YELLOW_B}[-]${RESET} The listening port will default to $defaultport."
	read -p "Procede with rule? (y/n): " lpverify

	if [ "$lpverify" == "n" ] || [ "$lpverify" == "N" ]; then
		echo -e "${YELLOW_B}[!]${RESET} Exiting. Please rerun the command with the \"-l\" option."
		exit 1

	elif [ "$lpverify" == "y" ] || [ "$lpverify" == "Y" ]; then
		LISTEN_PORT=$defaultport

	else
		echo -e "${YELLOW_B}[!]${RESET} Invalid option. Exiting. . ."
		exit 1
	fi


fi

echo -e "${GREEN_B}[+]${RESET} The following rule has been added: ${LISTEN_PORT} --> ${TARGET}:${TARGET_PORT}" 
echo -e "${GREEN_B}[+]${RESET} Whenever you want to communicate with ${TARGET} on port ${TARGET_PORT}, send to port ${LISTEN_PORT}." 
iptables -t nat -A PREROUTING -p tcp --dport "$LISTEN_PORT" -j DNAT --to "$TARGET":"$TARGET_PORT" -m comment --comment "Generated by Network Manager."
iptables -t nat -A POSTROUTING -p tcp --dport "$TARGET_PORT" -d "$TARGET" -j SNAT --to-source "$IP_ADDR" -m comment --comment "Generated by Network Manager."







